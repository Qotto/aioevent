#!/usr/bin/env python
# coding: utf-8
# Copyright (c) Qotto, 2019

import uuid
from datetime import datetime as py_datetime
from datetime import timezone

from typing import Dict, Any

from tonga.utils.gen_correlation_id import gen_correlation_id

__all__ = [
    'BaseModel',
]


class BaseModel:
    """ BaseModel Class, is root class of all events

    Attributes:
        schema_version (str): Includes the schema version of the record, it helps to keep applications compatible
                              with older records in the system
        record_id (str): Should be a unique identifier for your record. It should follow the UUID_ format.
                         There should be no duplicate values for this field in the entire system.
        partition_key (str): Should be a key determining to which partition your record will be assigned.
                             Records with the same *partition_key* value are guaranteed to be written to
                             the same partition. This field can, for instance, be derived from the aggregate ID.
        timestamp (int): UNIX timestamp in milliseconds, which is easy to read for machines.
        datetime (str): ISO-8601-encoded string, which is human readable, therefore useful for debugging purposes.
        correlation_id (str): An identifier that should be propagated across every call through the entire system.
                              The purpose of this identifier is to track the waterfall of actions triggered by a unique
                              upstream event. This is mainly used for debugging purposes.
        context (Dict[str, Any]): Somewhat similar to *correlation_id* in its implementation, because it
                                  should propagate to all downstream records. At each step, *context* can be completed
                                  with additional data, relevant to actions that were taken.

                                  Context has two purposes:
                                    - It facilitates debugging, by giving more information explaining why the record
                                      was generated.
                                    - It also provides a mechanism to keep relevant state of the upstream
                                      application, that can react to records generated by downstream
                                      applications. This enables developers to build reactive systems
                                      that can send asynchronous commands and respond to the results as
                                      soon as they are available, without keeping an internal state. This
                                      is equivalent to **stateless stream processing**, which greatly
                                      simplifies application code by eliminating state management.

    .. _UUID:
       https://en.wikipedia.org/wiki/Universally_unique_identifier
    """
    schema_version: str
    record_id: str
    partition_key: str
    timestamp: int
    datetime: str
    correlation_id: str
    context: Dict[str, Any]

    def __init__(self, record_id: str = None, schema_version: str = None, partition_key: str = None,
                 correlation_id: str = None, datetime: str = None, timestamp: int = None,
                 context: Dict[str, Any] = None) -> None:
        """ BaseModel constructor

        Args:
            record_id (str): Should be a unique identifier for your record. It should follow the UUID_ format.
                             There should be no duplicate values for this field in the entire system.
            schema_version (str): Includes the schema version of the record, it helps to keep applications compatible
                                  with older records in the system
            partition_key (str): Should be a key determining to which partition your record will be assigned.
                                 Records with the same *partition_key* value are guaranteed to be written to
                                 the same partition. This field can, for instance, be derived from the aggregate ID.
            timestamp (int): UNIX timestamp in milliseconds, which is easy to read for machines.
            datetime (str): ISO-8601-encoded string, which is human readable, therefore useful for debugging purposes.
            correlation_id (str): An identifier that should be propagated across every call through the entire system.
                                  The purpose of this identifier is to track the waterfall of actions triggered
                                  by a unique upstream event. This is mainly used for debugging purposes.
            context (Dict[str, Any]): Somewhat similar to *correlation_id* in its implementation, because it
                                      should propagate to all downstream records. At each step, *context* can be
                                      completed with additional data, relevant to actions that were taken.

                                      Context has two purposes:
                                        - It facilitates debugging, by giving more information explaining why the record
                                          was generated.
                                        - It also provides a mechanism to keep relevant state of the upstream
                                          application, that can react to records generated by downstream
                                          applications. This enables developers to build reactive systems
                                          that can send asynchronous commands and respond to the results as
                                          soon as they are available, without keeping an internal state. This
                                          is equivalent to **stateless stream processing**, which greatly
                                          simplifies application code by eliminating state management.

        .. _UUID:
           https://en.wikipedia.org/wiki/Universally_unique_identifier
        """
        if record_id is None:
            self.record_id = uuid.uuid4().hex
        else:
            self.record_id = record_id

        if partition_key is None:
            self.partition_key = '0'
        else:
            self.partition_key = partition_key

        if schema_version is None:
            self.schema_version = '0.0.0'
        else:
            self.schema_version = schema_version

        if correlation_id is None:
            self.correlation_id = gen_correlation_id()
        else:
            self.correlation_id = correlation_id

        if timestamp is None:
            self.timestamp = round(py_datetime.now(timezone.utc).timestamp()*1000)
        else:
            self.timestamp = timestamp

        if datetime is None:
            self.datetime = py_datetime.now(timezone.utc).isoformat()
        else:
            self.datetime = datetime

        if context is None:
            self.context = dict()
        else:
            self.context = context

    @classmethod
    def event_name(cls) -> str:
        """ Return BaseModel Class name, used by serializer

        Raises:
            NotImplementedError: Abstract def

        Returns:
            None
        """
        raise NotImplementedError

    @classmethod
    def from_data(cls, event_data: Dict[str, Any]):
        """ Serialize dict to BaseModel

        Args:
            event_data (Dict|str, Any]): Contains all BaseModel Class attribute for return an instanced class

        Raises:
            NotImplementedError: Abstract def

        Returns:
            None
        """
        raise NotImplementedError
